---
title: "Tutorial 3 - Markov chain Monte Carlo Calibration"
author: "Nan-Hung Hsieh"
date: "2019/05/23 (update: `r Sys.Date()`)"
output: 
  html_document:
  fig_caption: yes  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd('..')
wd <- getwd()
knitr::opts_knit$set(root.dir =  wd)
```

# 0 Prerequisites

```{r, include=FALSE}
source("MCSim/function.R")
```

Import the R packages

```{R message=FALSE, warning=FALSE}
library(tidyverse)
library(rstan)
library(bayesplot)
library(corrplot)
library(sensitivity)
library(pksensi)
theme_set(theme_light())
```

# 1 Linear Model

## 1.1 Single chain testing

Use model (`linear.model.R`) and input (`linear_mcmc.in.R`) files to run MCMC,

`linear.model.R`

```r
## linear.model.R ####
Outputs = {y}

# Model Parameters
A = 0; # 
B = 1;

# Statistical parameter
SD_true = 0;

CalcOutputs { y = A + B * t + NormalRandom(0,SD_true); }

End.
```

`linear_mcmc.in.R`

```r
## linear_mcmc.in.R ####
MCMC ("MCMC.default.out","", # name of output and restart file
     "",           # name of data file
     4000,0,       # iterations, print predictions flag,
     1,4000,       # printing frequency, iters to print
     10101010);    # random seed (default )

Level {
  
  Distrib(A, Normal, 0, 2); # prior of intercept coefficient
  Distrib(B, Normal, 1, 2); # prior of slope coefficient
  
  Likelihood(y, Normal, Prediction(y), 0.05); #  # exact SD
  
  Simulation {
    PrintStep (y, 0, 10, 1); #seq(0, 10 1)
    Data  (y, 0.0, 0.15, 2.32, 4.33, 4.61, 6.68, 7.89, 7.13, 7.27, 9.4, 10.0);
  }
}

End.
```

Plotting the data

```{r}
x <- seq(0, 10, 1)
y <- c(0.0, 0.15, 2.32, 4.33, 4.61, 6.68, 7.89, 7.13, 7.27, 9.4, 10.0)
plot(x, y)
```

```{r}
model <- "linear.model.R"
input <- "linear_mcmc.in.R"
set.seed(1111) 
out1 <- mcsim(model, input) 
```

After the simulation, we need to diagnosis the result, 

```{r}
plot(out1$A.1., type = "l", xlab = "Iteration", ylab = "")
lines(out1$B.1., col = 2)
legend("topright", legend = c("Intercept", "Slope"), col = c(1,2), lty = 1)
plot(out1$A.1., out1$B.1., type = "b", xlab = "Intercept", ylab = "Slope")
```

Basically, the "burn-in" period is not necessary to include in our analysis

```{r}
str <- ceiling(nrow(out1)/2) + 1
end <- nrow(out1)
j <- c(str:end)
plot(out1$iter[j], out1$A.1.[j], type = "l", xlab = "Iteration", ylab = "Intercept")
plot(out1$iter[j], out1$B.1.[j], type = "l", xlab = "Iteration", ylab = "Slope")
plot(out1$A.1.[j], out1$B.1.[j], type = "b", xlab = "Intercept", ylab = "Slope")
cor(out1$A.1.[j], out1$B.1.[j])
```

Check kernel density

```{r}
out1$A.1.[j] %>% density() %>% plot()
out1$B.1.[j] %>% density() %>% plot()
```

The `MCMC.check.out` is generated by the last iteration of simulation. It is used to quick check the output.

```{r}
# Visualizing the fitting result 
chk <- read.delim("MCMC.check.out")
```

```{r}
plot(chk$Time, chk$Data, xlab = "x", ylab = "y")
lines(chk$Time, chk$Prediction)
```

## 1.2 Multi-chains simulation

Use `set.seed()` to create the different chains with different random seed and run simulation.

```{r}
# Check convergence
model <- "linear.model.R"
input <- "linear_mcmc.in.R"
set.seed(2234) 
out2 <- mcsim(model, input) # Generate the 2nd chain
set.seed(3234) 
out3 <- mcsim(model, input) # Generate the 3rd chain
set.seed(4234) 
out4 <- mcsim(model, input) # Generate the 4th chain
```

Use `mcmc_array()` to create the 3-D array (iterations * chains * parameters) to store all outputs.

```{r}
sims <- mcmc_array(data = list(out1,out2,out3,out4))
dim(sims)
```

The **bayesplot** package can use to visualize output. 

```{r}
parms_name <- c("A.1.","B.1.")
color_scheme_set("mix-blue-red")
mcmc_trace(sims, pars = parms_name, facet_args = list(ncol = 1, strip.position = "left"))
```

Kernel density plots of MCMC draws

```{r}
mcmc_dens_overlay(x = sims[j,,], pars = parms_name)
mcmc_dens_overlay(x = sims[j,,], pars = "LnData")
```

Pairs plots from MCMC draws

```{r}
mcmc_pairs(sims[j,,], pars = parms_name, off_diag_fun = "hex")
```

Rank histogram plot ([Vehtari et al. 2019](https://arxiv.org/abs/1903.08008))

```{r}
mcmc_rank_hist(sims, pars = parms_name)
```

```{r}
mcmc_rank_overlay(sims, pars = parms_name)
```


The **rstan** package can use to analyze and diagnosis output. 

```{r}
monitor(sims[,,parms_name], digit=4) 
```

Finally, evaluate the confidence interval of prediction through setpoints method. Prepare the input file `linear_setpts.in.R`

```r
## ./mcsim.linear.model.R.exe linear_setpts.in.R ####
SetPoints ("", "setpts.out", 0, A, B);

Simulation { 
  PrintStep (y, 0, 10, 1);
  Data  (y, -0.0289654, 1.15968, 2.32502, 3.33289, 4.61105, 5.6818, 
         6.89044, 8.13242, 9.27033, 10.4522, 11.6703);
} 

End.
```


```{r}
X <- sims[j,,] %>% matrix(nrow = 1000*4) 
write.table(X, file = "setpts.out", row.names = F, sep = "\t")
X_setpts <- mcsim("linear.model.R", "linear_setpts.in.R")
head(X_setpts)
```

```{r}
vars <- names(X_setpts)
index <- which(vars == "y_1.1" | vars == "y_1.11")
X <- apply(X_setpts[index[1]:index[2]], 2, quantile,  c(0.5, 0.025, 0.975)) %>% t()
colnames(X) <- c("median", "LCL", "UCL")
df <- as.data.frame(X)
x <- seq(0, 10, 1)
df$x <- x
df
```


```{r}
y <- c(0.0, 0.15, 2.32, 4.33, 4.61, 6.68, 7.89, 7.13, 7.27, 9.4, 10.0)
obs_data <- data.frame(x, y)
ggplot(df, aes(x = x, y = median)) +
    geom_ribbon(aes(ymin = LCL, ymax = UCL), fill = "grey70", alpha = 0.5) + 
    geom_line() +
    geom_point(data = obs_data, x=x, y=y) +
    labs(x = "x", y = "y")
```


# 2 Ethylbenzene PBPK Model

Prepare [**model**](https://raw.githubusercontent.com/nanhung/MCSim_under_R/master/modeling/EB/EB.model.R) (`perc.model.R`) and input files in the following simulation. The input files include straightforward ([`EB.in.R`](https://raw.githubusercontent.com/nanhung/MCSim_under_R/master/modeling/EB/EB.in.R)), Monte Carlo ([`EB_mtc.in.R`](https://raw.githubusercontent.com/nanhung/MCSim_under_R/master/modeling/EB/EB_mtc.in.R)), setpints ([`EB_setpts.in.R`](https://raw.githubusercontent.com/nanhung/MCSim_under_R/master/modeling/EB/EB_setpts.in.R)), MCMC  ([`EB_MCMC.in.R`](https://raw.githubusercontent.com/nanhung/MCSim_under_R/master/modeling/EB/EB_MCMC.in.R)) simulation, and MCMC for model evaluation ([`EB_MCMC_setpts.in.R`](https://raw.githubusercontent.com/nanhung/MCSim_under_R/master/modeling/EB/EB_MCMC_setpts.in.R)).

## 2.1 Model verification

Run EB-PBPK model ("EB.model.R") and input files ("EB.in.R"), the exposure condition is continuous inhalation of 100 ppm Ethylbenzene (EB) for 4 hours and plot the time-course of blood concentration from 0 to 6 hour. 

1. Modeling

```{r}
out <- mcsim(model = "EB.model.R", input = "EB.in.R", dir = "modeling/EB")
exp <- readsims(out, exp = 3) 
head(exp)
```

2. Unit transfer and add study data

```{r}
MW <- 106.16 # g/mol
exp$Cvtot_mg <- exp$Cvtot * MW * 1000 # mol/L -> mg/L 
data_t <- c(4, 4.5, 5, 5.5, 6) # Obsrvation time 
data_c <- c(1.93, 1.29, 0.87, 0.55, 0.38) # Obsrvation concentration
sd <- c(0.15, 0.15, 0.24, 0.11, 0.05)
sd.up <- data_c + sd
sd.dn <- data_c - sd
```

3. Plotting 

Compare the simulation result with experiment data as:

```{r}
plot(data_t, data_c, main = "Exposure: 100 ppm", xlab = "Time (hr)", ylab = "Concentration (mg/L)", xlim = c(0, 6), ylim = c(0, 2.5))
lines(exp$Time, exp$Cvtot_mg)
arrows(data_t, sd.dn, data_t, sd.up, code=3, length=0.02, angle=90)
legend("topright", legend = c("Data", "Model"), lty = c(NA, 1), pch = c(1, NA))
```

## 2.2 Uncertainty analysis

1. Setting the uncertainty for model parameter

Here we used 11 model parameters include body weight (uniform distribution from 35g to 55g), 
7 partition coefficients (set 2 times difference from baseline) and 3 Michaelis-Menten reaction rate constant (set 4 times difference from baseline). The distribution setting in input file is as,

```r
Distrib (BW, Uniform, 0.035, 0.055);

Distrib (Pb, Uniform, 21.35, 85.4);
Distrib (Pl, Uniform, 0.98, 3.92);
Distrib (Pf, Uniform, 18.2, 72.8);
Distrib (Pm, Uniform, 0.3045, 1.218);
Distrib (Pvrg, Uniform, 0.98, 3.92);
Distrib (Ppu, Uniform, 0.98, 3.92);
Distrib (Pbr, Uniform, 0.98, 3.92);

Distrib (VmaxC, Uniform, 1.5975, 25.56);
Distrib (VmaxClu, Uniform, 3.35, 53.6);
Distrib (VmaxCvr, Uniform, 4.35, 69.6);
```

2. Modeling

```{r}
out <- mcsim(model = "EB.model.R", input = "EB_mtc.in.R", dir = "modeling/EB")
```


3. Data wrangling

```{r}
vars <- names(out)
index <- which(vars == "Cvtot_1.2" | vars == "Cvtot_1.61")
time <- seq(0.1, 6, 0.1) # corresponding time-points
exp_data <- data.frame(data_t, data_c)

X <- apply(out[,index[1]:index[2]], 2, quantile,  c(0.5, 0.025, 0.975)) %>% t() * MW * 1000 # 95% CI
colnames(X) <- c("median", "LCL", "UCL")
df <- as.data.frame(X)
df$time <- time
```

4. Plotting

```{r, warning=F}
ggplot(df, aes(x = time, y = median)) +
    geom_ribbon(aes(ymin = LCL, ymax = UCL), fill = "grey70", alpha = 0.5) + 
    geom_line() +
    geom_point(data = exp_data, aes(x = data_t, y = data_c)) +
    geom_errorbar(data = exp_data, aes(x = data_t, y = data_c, ymin=data_c-sd, ymax=data_c+sd), width=.1) +
    labs(x = "Time (hr)", y = "Concentration (mg/L)")
```


## 2.3 Morris elementary effects screening

1. Argument setting

```{r}
BW <- 0.043  

Pb <- 42.7
Pl <- 1.96
Pf <- 36.4
Pm <- 0.609
Pvrg <- 1.96
Ppu <- 1.96
Pbr <- 1.96

VmaxC <- 6.39
VmaxClu <- 13.4
VmaxCvr <- 17.4

baseline <- c(BW, Pb, Pl, Pf, Pm, Pvrg, Ppu, Pbr, VmaxC, VmaxClu, VmaxCvr)
limit <- c(1.2, rep(2, 7), rep(4, 3))
binf <- baseline/limit
bsup <- baseline*limit

parameters <- c("BW", "Pb", "Pl", "Pf", "Pm", "Pvrg", "Ppu", "Pbr", "VmaxC", "VmaxClu", "VmaxCvr")
```

2. Generate parameter matrix

```{r}
set.seed(1234)
x <- morris(model = NULL, factors = parameters, r = 512,
            design = list(type = "oat", levels = 5, grid.jump = 3),
            binf = binf, bsup = bsup)
X <- cbind(1, x$X)
write.table(X, file = "setpts.out", row.names = F, sep = "\t")
```

3. Modeling

```{r}
out <- mcsim(model = "EB.model.R",  input = "EB_setpts.in.R", dir = "modeling/EB")
```

4. Plotting result

```{r}
str <- which(names(out) == "Cvtot_1.1")
end <- which(names(out) == "Cvtot_1.5")
par(mfrow = c(2,3), mar = c(2,2,1,1))
for (i in str:end){
tell(x, log(out[,i]))
plot(x, xlim=c(0,3), main = paste("Time = ",4 + (i - str)*0.5, "hr"))
abline(v = 0.5)
}
```


## 2.4 Uncertainty analysis again

Adjust the range of Pf (to 4 times different), VmaxC (to 8 times different) and VmaxCvr (to 8 times different), and check the possible output.

```{r}
baseline <- c(BW, Pb, Pl, Pf, Pm, Pvrg, Ppu, Pbr, VmaxC, VmaxClu, VmaxCvr)
new_limit <- c(1.2, 2, 2, 4, rep(2, 4), 8, 4, 8)
binf <- baseline/new_limit
bsup <- baseline*new_limit
dist <- c(rep("Uniform", 8), "LogUniform", "Uniform", "LogUniform")
q.arg <- list(list(min = binf[1], max = bsup[1]),
              list(min = binf[2], max = bsup[2]),
              list(min = binf[3], max = bsup[3]),
              list(min = binf[4], max = bsup[4]),
              list(min = binf[5], max = bsup[5]),
              list(min = binf[6], max = bsup[6]),
              list(min = binf[7], max = bsup[7]),
              list(min = binf[8], max = bsup[8]),
              list(min = binf[9], max = bsup[9]),
              list(min = binf[10], max = bsup[10]),
              list(min = binf[11], max = bsup[11])) 
outputs <- c("Cvtot")
conditions <- c("Cppm = NDoses (2, 100, 0, 0, 4 )")
```

Run MC simulation

```{r}
set.seed(2222)
y<-solve_mcsim(mName = "EB.model.R", params = parameters, vars = outputs,
               monte_carlo = 1000, dist = dist, q.arg = q.arg, time = time, 
               condition = conditions, rtol = 1e-9, atol = 1e-11)
```

Check result

```{r}
X <- y * MW * 1000
pksim(X)
points(data_t, data_c)
arrows(data_t, sd.dn, data_t, sd.up, code=3, length=0.02, angle=90)
```

## 2.5 MCMC calibration

### 2.5.1 Single chain testing

**1. MCMC Modeling**

Run MCMC for single chain the iteration is set to 2000

```{r}
set.seed(1234)
system.time(out1 <- mcsim(model = "EB.model.R", input = "EB_mcmc.in.R", dir = "modeling/EB"))
tail(out1)
```

Check simulation result with the parameter from the last iteration

```{r}
check_df <- read.delim("MCMC.check.out")
check_df$Data_mgl <- check_df$Data * MW * 1000
check_df$Prediction_mgl <- check_df$Prediction * MW * 1000

plot(check_df$Time, check_df$Data_mgl, ylim = c(0, 4),
     xlab = "Time (hr)", ylab = "Concentration (mg/L)")
lines(check_df$Time, check_df$Prediction_mgl)
plot(check_df$Data_mgl, check_df$Prediction_mgl, log = "xy", 
     xlab = "Observation", ylab = "Prediction")
abline(0,1) # calibration curve
```

**2. Setpoints analysis**

Use output file to do setpoints analysis. The setpoints file (`EB_MCMC_setpts.in.R`) need to build in this analysis. The setpoints analysis aims to perform the simulation based on the posterior of model output. Through the setpoints analysis, we can check all possible outputs (e.g., 95% confidence interval) and detect the data points that are not covered in the simulation routes.

Run simulation

```{r}
out <- mcsim(model = "EB.model.R",  input = "EB_MCMC_setpts.in.R", dir = "modeling/EB")
tail(out)
```

Data processing

```{r}
str <- which(names(out) == "Cvtot_1.1")
end <- which(names(out) == "Cvtot_1.5")
vars <- names(out)
index <- which(vars == "Cvtot_1.1" | vars == "Cvtot_1.5")
X <- apply(out[,index[1]:index[2]], 2, quantile,  c(0.5, 0.01, 0.99))
dat <- t(X) * MW * 1000
colnames(dat) <- c("median", "LCL", "UCL")
df <- as.data.frame(dat)
df$time <- data_t
head(df)
```

Plotting

```{r, eval=T}
ggplot(df, aes(x = time, y = median)) +
    geom_ribbon(aes(ymin = LCL, ymax = UCL), fill = "grey70", alpha = 0.5) + 
    geom_line() +
    geom_point(data = exp_data, aes(x = data_t, y = data_c)) +
    geom_errorbar(data = exp_data, aes(x = data_t, y=data_c, ymin=data_c-sd, ymax=data_c+sd), width=.05) +
    labs(x = "Time (hr)", y = "Concentration (mg/L)")
```

**3. Result diagnosis**

Trace plot

```{r}
str <- ceiling(nrow(out1)/2) + 1
end <- nrow(out1)
j <- c(str:end) # discard burn-in
par(mfrow = c(3,4), mar = c(2,2,2,1))
for (i in 2:12){
  plot(out1[j,1], out1[j,i], type = "l", main = names(out1)[i])
}
```

Auto correlation

```{r}
par(mfrow = c(3,4), mar = c(2,2,4,1))
for (i in 2:12){
  acf(out1[j,i], main = names(out1)[i])
}
```

Density plot

```{r}
par(mfrow = c(3,4), mar = c(2,2,2,1))
for (i in 2:12){
  out1[j,i] %>% density() %>% plot(type = "l", main = names(out1)[i])
}
```

Correlation matrix

```{r}
out1[,2:12] %>% cor() %>% corrplot(method = "number")
```

### 2.5.2 Multi chains testing

**1. MCMC Modeling**

This is an example to run multiple chain without parallel

```{r, eval = T}
set.seed(2233)
out2 <- mcsim(model = "EB.model.R", input = "EB_mcmc.in.R", dir = "modeling/EB")
set.seed(3344)
out3 <- mcsim(model = "EB.model.R", input = "EB_mcmc.in.R", dir = "modeling/EB")
set.seed(4455)
out4 <- mcsim(model = "EB.model.R", input = "EB_mcmc.in.R", dir = "modeling/EB")
```

We can also use parallel computing to run multiple chains at the same time. 

```{r, eval=F}
parallel::detectCores()
```

Through **parallel** package, we can detect the available core in the working computer.

```{r, eval=F}
library(rstudioapi)
set.seed(1234)
jobRunScript(workingDir = getwd(), path = "examples/EB_job.R", importEnv = T, exportEnv = "job_1")
set.seed(2345)
jobRunScript(workingDir = getwd(), path = "examples/EB_job.R", importEnv = T, exportEnv = "job_2")
```

```{r, eval=F}
set.seed(3344)
jobRunScript(workingDir = getwd(), path = "examples/EB_job.R", importEnv = T, exportEnv = "job_3")
set.seed(4455)
jobRunScript(workingDir = getwd(), path = "examples/EB_job.R", importEnv = T, exportEnv = "job_4")
```

Use `mcmc_array()` to store output as an object

```{r}
x <- mcmc_array(data = list(out1, out2, out3, out4))
```

For parallel

```{r, eval=F}
x <- mcmc_array(data = list(job_1$out, job_2$out, job_3$out, job_4$out))
```


```{r}
dim(x)
```

**2. Result diagnosis**

Kernel density

```{r}
pars <- c("BW.1.", "Pb.1.", "Pl.1.", "Pf.1.", "Pm.1.", "Pvrg.1.", "Ppu.1.", "Pbr.1.", "VmaxC.1.", "VmaxClu.1.", "VmaxCvr.1.")
mcmc_dens_overlay(x[j,,], pars = pars)
mcmc_dens_overlay(x[j,,], pars = "LnData")
```

Trace plot

```{r}
mcmc_trace(x[j,,], pars = pars)
```

Pair plot

```{r}
mcmc_pairs(x[j,,], pars = c("Pb.1.", "VmaxC.1.", "VmaxClu.1.", "VmaxCvr.1."), off_diag_fun = "hex")
```

Create report

```{r}
monitor(x, digit = 4)
```

**3. Evaluation of model fit**

1. Setpoints analysis

```{r}
X <- x[j,,] %>% matrix(nrow = 20000) 
write.table(X, file = "setpts.out", row.names = F, sep = "\t")
X_setpts <- mcsim(model = "EB.model.R", input = "EB_setpts.in.R", dir = "modeling/EB")
head(X_setpts)
```

2. Tidy data with median and 95% confidence interval

```{r}
vars <- names(X_setpts)
index <- which(vars == "Cvtot_1.1" | vars == "Cvtot_1.5")
X <- apply(X_setpts[index[1]:index[2]], 2, quantile,  c(0.5, 0.025, 0.975)) %>% t() * MW * 1000
colnames(X) <- c("median", "LCL", "UCL")
df <- as.data.frame(X)
x <- seq(0, 10, 1)
df$time <- c(4.0, 4.5, 5.0, 5.5, 6.0)
df
```

3. Plot result

```{r, warning=F}
y <- c(0.0, 0.15, 2.32, 4.33, 4.61, 6.68, 7.89, 7.13, 7.27, 9.4, 10.0)
ggplot(df, aes(x = time, y = median)) +
    geom_ribbon(aes(ymin = LCL, ymax = UCL), fill = "grey70", alpha = 0.5) + 
    geom_line() +
    geom_point(data = exp_data, aes(x = data_t, y = data_c)) +
    geom_errorbar(data = exp_data, aes(x = data_t, y=data_c, ymin=data_c-sd, ymax=data_c+sd), width=.05) + 
    labs(x = "Time (hr)", y = "Concentration (mg/L)")
```

# Software package

Check the software package version that will be used in this example.

```{r, eval=T}
devtools::session_info()
mcsim_version()  
```

```{r, include=FALSE}
clear()
```
